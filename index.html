<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4x4 Number Grid</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #f8f8f8;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 60px);
      grid-template-rows: repeat(4, 60px);
      gap: 10px;
    }
    .cell {
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      border: 1px solid #ccc;
      font-size: 1.5rem;
      width: 60px;
      height: 60px;
      border-radius: 8px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
  </style>
</head>
<body>
  <div class="grid" id="numberGrid">
    <!-- Grid cells will be inserted here by JavaScript -->
  </div>
  <div style="position: fixed; top: 12px; left: 12px; background: rgba(255,255,255,0.85); padding: 6px 12px; border-radius: 6px; font-size: 0.95rem; color: #333; box-shadow: 0 1px 4px rgba(0,0,0,0.06); z-index: 1000;">
    Press backspace to undo
  </div>
  <div id="overlay" style="position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none;"></div>
  <script>
    // Initial 4x4 grid of numbers (customizable)
    const gridNumbers = [
      [5, 4, 1, 8],
      [2, 8, 2, 3],
      [2, 6, 2, 3],
      [5, 1, 7, 1]
    ];

    const grid = document.getElementById('numberGrid');
    // Store cell divs for easy access
    const cellDivs = [];
    // Track active/inactive state for each number
    const isActive = Array.from({ length: 4 }, () => Array(4).fill(true));
    gridNumbers.forEach((row, rowIndex) => {
      row.forEach((num, colIndex) => {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = num;
        grid.appendChild(cell);
        if (!cellDivs[rowIndex]) cellDivs[rowIndex] = [];
        cellDivs[rowIndex][colIndex] = cell;
      });
    });

    // Rectangle drawing logic
    const overlay = document.getElementById('overlay');
    let rect = null;
    let startX = 0, startY = 0;
    let drawing = false;

    // Track all user rectangles and their numbers
    const rectangles = [];

    // Helper to get grid's position relative to viewport
    function getGridRect() {
      return grid.getBoundingClientRect();
    }

    // Mouse events on the grid
    grid.addEventListener('mousedown', (e) => {
      const gridRect = getGridRect();
      startX = e.clientX - gridRect.left;
      startY = e.clientY - gridRect.top;
      drawing = true;
      rect = document.createElement('div');
      rect.style.position = 'absolute';
      rect.style.left = `${startX + gridRect.left}px`;
      rect.style.top = `${startY + gridRect.top}px`;
      rect.style.width = '0px';
      rect.style.height = '0px';
      rect.style.borderRadius = '5px';
      rect.style.background = 'rgba(0, 123, 255, 0.2)';
      rect.style.border = '2px solid #007bff';
      rect.style.pointerEvents = 'none';
      overlay.appendChild(rect);
      overlay.style.pointerEvents = 'auto';
    });

    window.addEventListener('mousemove', (e) => {
      if (!drawing || !rect) return;
      const gridRect = getGridRect();
      let currX = e.clientX - gridRect.left;
      let currY = e.clientY - gridRect.top;
      // Clamp to grid bounds
      currX = Math.max(0, Math.min(currX, gridRect.width));
      currY = Math.max(0, Math.min(currY, gridRect.height));
      const x = Math.min(startX, currX);
      const y = Math.min(startY, currY);
      const w = Math.abs(currX - startX);
      const h = Math.abs(currY - startY);
      rect.style.left = `${x + gridRect.left}px`;
      rect.style.top = `${y + gridRect.top}px`;
      rect.style.width = `${w}px`;
      rect.style.height = `${h}px`;
    });

    window.addEventListener('mouseup', (e) => {
      if (drawing) {
        drawing = false;
        overlay.style.pointerEvents = 'none';

        // Calculate rectangle bounds relative to grid
        const gridRect = getGridRect();
        let endX = e.clientX - gridRect.left;
        let endY = e.clientY - gridRect.top;
        // Clamp to grid bounds
        endX = Math.max(0, Math.min(endX, gridRect.width));
        endY = Math.max(0, Math.min(endY, gridRect.height));
        const x1 = Math.min(startX, endX);
        const y1 = Math.min(startY, endY);
        const x2 = Math.max(startX, endX);
        const y2 = Math.max(startY, endY);

        // Get cell size
        const cellWidth = gridRect.width / 4;
        const cellHeight = gridRect.height / 4;
        const selectedNumbers = [];
        const selectedCells = [];
        const selectedCoords = [];
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            // Only consider active numbers
            if (!isActive[row][col]) continue;
            // Cell center
            const cellCenterX = (col + 0.5) * cellWidth;
            const cellCenterY = (row + 0.5) * cellHeight;
            if (
              cellCenterX >= x1 && cellCenterX <= x2 &&
              cellCenterY >= y1 && cellCenterY <= y2
            ) {
              selectedNumbers.push(gridNumbers[row][col]);
              selectedCells.push(cellDivs[row][col]);
              selectedCoords.push([row, col]);
            }
          }
        }
        console.log('Numbers inside rectangle:', selectedNumbers);

        // Reset color of all active cells
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            if (isActive[row][col]) {
              cellDivs[row][col].style.color = '';
            }
          }
        }
        // If sum is 10, color selected cells and mark as inactive
        const sum = selectedNumbers.reduce((a, b) => a + b, 0);
        if (sum === 10) {
          selectedCoords.forEach(([row, col]) => {
            cellDivs[row][col].style.color = 'lightgray';
            isActive[row][col] = false;
          });
          // Save this rectangle for undo, including the rectangle element
          rectangles.push({ coords: selectedCoords, numbers: selectedNumbers, rectElem: rect });
          rect = null; // Don't remove the rectangle element
        } else {
          // Remove the rectangle if not a valid selection
          if (rect) {
            overlay.removeChild(rect);
            rect = null;
          }
        }
      }
    });

    // Undo last rectangle on Backspace
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace' && rectangles.length > 0) {
        e.preventDefault();
        const last = rectangles.pop();
        last.coords.forEach(([row, col]) => {
          isActive[row][col] = true;
          cellDivs[row][col].style.color = '';
        });
        // Remove the rectangle element from the overlay
        if (last.rectElem && overlay.contains(last.rectElem)) {
          overlay.removeChild(last.rectElem);
        }
      }
    });
  </script>
</body>
</html> 